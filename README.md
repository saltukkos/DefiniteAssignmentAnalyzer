# DefiniteAssignmentAnalyzer

### Описание решения

#### Общая идея

1. Нет смысла при каждом заходе в функцию реанализировать, какие переменные она будет инициализировать, а к каким будет обращаться. Достаточно один раз проанализировать функцию и сохранить контекст: что мы инициализируем и от чего мы зависим. При вызове уже проанализированной функции берём существующий контекст и проверяем на основе локального состояния, легальный ли вызов функции происходит. После этого выводим ошибки и обновляем локальное состояние.
2. Условные вызовы: разница между условными и безусловными вызовами заключается в том, что условные вызовы не должны обновлять состояние внешнего скопа (поскольку они не гарантированно выполняются, значит мы не можем расчитывать на инициализации переменных, произведённых внутри вызываемого метода), однако сами ошибки внутри нужно так же проверять. Соответственно, при наличии результата анализа вызываемого метода, разница между условным и безусловным вызовом будет только в одной ифке с применением списка инициализированных переменных в текущий контекст.
3. Но всё усложняет рекурсия: из-за неё мы не сможем при обработке вызова метода заранее знать всю собранную информацию. Если бы рекурсия была возможна только на себя, то её можно было бы игнорировать при анализе, потому что она не даст дополнительных инициализаций и не даст дополнительных зависимостей от внешних инициализаций. Однако в нашем случае рекурсия может содержить промежуточные методы `(A -> B -> C -> A)`

#### Обработка рекурсии

Стоит заметить, что рекурсия может быть двух видов: когда все вызовы на пути рекурсии безусловные, и когда есть хотя бы один условный.

В случае, когда все вызовы безусловные, код после рекурсии недостижим. В иделае можно показать инспекцию, а весь код после соответствующих вызовов будет unreachable и его можно не анализировать, но я думаю можно реализовать любое поведение. Например, можно считать, что рекурсия когда-то прервётся и, соответственно, остальные стейтменты могут выполниться.

В случае, когда есть хотя бы один условный вызов, то заметим, что мы всё ещё можем проанализировать, что эти методы инициализируют, потому что условные вызовы при анализе инициализаций не должны учитываться (описано в пункте 2).

При анализе доступа к неинициализированным переменным, однако, уже нужно учитывать даже условные вызовы. Рассмотрим пример, `А -> B -> C -> A`. Предположим, мы хотим понять, какие переменные обязаны быть инициализированы перед вызовом  метода `А`. При попытке сбора информации по всему стеку, когда мы заново упрёмся в метод `А`, на самом деле повторный вызов можно просто проигнорировать, ведь все внешние зависимости метода `А` будут учтены в рамках этого анализа и без учёта повторного вызова.

Однако тут стоит учитывать, что игнорирование вызова метода приведёт к тому, что локальный результат анализа метода `С` (а как следствие, и метода `B`) будет неполным. Если его сохранить и переиспользовать, например, при анализе метода `D -> C`, то мы можем ошибочно пропустить обращение к неинициализированной переменной, которое было внутри метода `А`.

~~Возможные варианты борьбы с проблемой, когда приходится пропускать вызовы методов из-за наличия рекурсии:~~
1. ~~Не сохраняем результат анализа метода.~~
      - ~~Это какая-то это полумера, ведь достаточно поместить весь код во внутрь одного объемлющего локального метода и добавить рекурсивный вызов, чтобы потерять все премущества переиспользования анализа методов и получить плохую алгоритмическую сложность~~
2. ~~Сохраняем результат не глобально, а внутри текущего контекста~~
      - ~~Тут нужно подумать, когда именно можно переиспользовать контекст. Например, можно ли переиспользовать результат от `С` между `А->B->C->A`, `А->C->A` и `B->C->A->B`~~
3. ~~А что, если записывать все зависимости на инициализиацию в общее место для всех методов, участвующих в рекурсии, будет ли это корректно?~~
      - ~~Нет, не будет. Лёгкий контрпример: `A() {out(var1); B();} B() {var1 = 1; A();}`~~

        ~~Метод `A` зависит от инициализации `var1`, однако метод `B` - не зависит.~~
4. ~~Можно ли как-то сохранять неполную информацию, чтобы было понятно, что при доступе к частично построенным данным для `B`, нужно просто приаппендить туда данные от `А`, чтобы получить полный результат?~~
      - ~~Да, но данные для `B` и `C` можно будет построить проще.~~

      - ~~После построения данных для `А`, при попытке анализа любого другого метода из цепочки рекурсии мы уже будем иметь полные данные на руках для метода `A`, и при анализе метода `C` нам уже не придётся ничего пропускать. Соответственно, мы сможем построить полный результат анализа для `C`, а используя его - полный результат и для `B`.~~

      - ~~Чтобы слишком не усложнять решение, можно вообще ничего не делать дополнительного, главное сохранить результат для `А`. Потом, при построении результата анализа для `B` или для `C`, мы за один проход получим сразу все нужные данные.~~

      - ~~В ещё более сложных случаях (когда есть несколько разных "цепей" рекурсии, проходящих через пересекающиеся методы), мы всё ещё будем делать лишнюю работу, можно было бы всё-таки применять к результатам частичного анализа метода построенные данные, но оставлю это как место для потенциального улучшения.~~

**UPD**: После обдумывания того, результаты анализа каких методов всё-таки можно сохранять при обработке рекурсивного метода, получилось понять, что на самом деле можно сохранять результаты анализа и "частично" проанализированных методов. Ведь если мы пропускаем вызов метода `Foo` при анализе метода `Bar`, то это значит, что `Foo` будет обработан по стеку выше. В таком случае, если в `Foo` было обращение к какой-то переменной `a`, то возможны два случая:
1. Переменная `a` уже была инициализирована и обращение не привело к ошибке. В таком случае последующие обращения к переменной `a` так же не приведут к ошибкам, потому что переменная уже не может перейти из инициализированного состояния в неинициализированное. В таком случае можно сохранить информацию об анализе `Bar` без учёта вызова `Foo`, потому что это гарантированно не пропустит никаких ошибок.
2. Переменная `a` ещё не была инициализирована и обращение привело к ошибке. В таком случае последующие обращения к переменной `a` так же могут привести к ошибкам, в случае, если перменная так и не будет инициализирована к моментам следующих вызовов, например, последующий вызов метода `Bar` извне метода `Foo`:

```
var a;
var b;
func Foo {
    if (smth) Bar();
    print(a);
}

func Bar {
    if (smth) Foo();
    print(b);
}

Foo(); // use of unassigned "a" and "b"
Bar(); // use of unassigned "b" but not "a"?
```
Однако практического смысла в последующих ошибках о тех же переменных немного, поскольку программисту не станет лучше, если он увидит одну и ту же ошибку много раз. Таким образом, и в этом случае можно сохранить информацию об анализе `Bar` без учёта вызова `Foo`. 

В таком случае ради консистентности описанного поведения с вызовами нерекурсивных методов стоит после первого обращения к неинициализированной переменной начать считать её инициализированной. В таком случае мы не будем получать дублирующихся ошибок при вызове любых методов.
